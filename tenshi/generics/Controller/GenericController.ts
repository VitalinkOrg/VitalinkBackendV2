import JWTObject  from 'tenshi/objects/JWTObject';
import Validations  from 'tenshi/helpers/Validations';
import HttpAction from 'tenshi/helpers/HttpAction';

import ConfigManager  from "tenshi/config/ConfigManager";
import { EntityTarget, RequestHandler } from 'tenshi/generics/index';

import IGenericRepository from 'tenshi/generics/Repository/IGenericRepository';
import GenericRepository from 'tenshi/generics/Repository/GenericRepository';

import IGenericController from 'tenshi/generics/Controller/IGenericController';
import ControllerObject from 'tenshi/objects/ControllerObject';

import { createControllerObject } from 'tenshi/services/ControllerObjectFactory';

import { ConstHTTPRequest, ConstStatusJson, ConstMessagesJson } from "tenshi/consts/Const";
import GenericValidationController from './GenericValidationController';

/*
    This class have the necessary methods (CRUDS) to send into the routing
    You need to send the entity type, the models generated by de TYPE ORM &&
    Then you send the controller object, with all the specific names of the specific entity
    PD: IF YOU NEED TO OVERRIDE OR ADDED MORE METHODS, YOU NEED TO CREATE ANOTHER CONTROLLER AND EXTEND THIS
*/7
export default  class GenericController extends GenericValidationController implements IGenericController {
    private controllerObj: ControllerObject;
    private entityType : EntityTarget<any>;
    /**
     * Constructor of the GenericController class.
     * This class needs the type of the entity of the ORM, and the controller object.
     * @param {EntityTarget<any>} entityType - The type of the entity of the ORM.
     * @param {IGenericRepository | null} repositoryClass - The repository class of the entity.
     *                                                      If it's not passed, a new instance of GenericRepository will be created.
     */
    constructor(entityType: EntityTarget<any>, repositoryClass: IGenericRepository | null = null) {
        super();
        // Create the controller object using the entity type.
        this.controllerObj = createControllerObject(entityType);

        // Set the entity type.
        this.entityType = entityType;

        // Check if the repository class is passed.
        // If not, create a new instance of GenericRepository using the entity type.
        // Otherwise, set the repository class.
        if(repositoryClass == null){
            this.setRepository(new GenericRepository(this.entityType));
        }else{
            this.setRepository(repositoryClass);
        }
    }
   

    /**
     * Getter and Setters
     */
    public getControllerObj(): ControllerObject {
        return this.controllerObj;
    }

    public getRepository(): IGenericRepository {
        return this.getValidationRepository();
    }


    /**
     * This function is used to insert a new entity into the database.
     * It performs the following steps:
     * 1. Validates the role of the user.
     * 2. Validates the required fields of the entity.
     * 3. Validates the regex of the entity.
     * 4. Sets the user id of the entity.
     * 5. Inserts the entity into the database.
     * 6. Returns a success response if the insertion is successful.
     * 7. Returns a database error response if there is an error while inserting the entity.
     * 8. Returns a general error response if there is an error while performing the above steps.
     *
     * @param {RequestHandler} reqHandler - The request handler object.
     * @return {Promise<any>} A promise that resolves to the success response if the insertion is successful.
     */
    async insert(reqHandler: RequestHandler): Promise<any> {
        // Execute the returns structure
        const httpExec : HttpAction = reqHandler.getResponse().locals.httpExec;

        try{
            // Validate the role of the user
            const validation : Validations = reqHandler.getResponse().locals.validation;
            const jwtData : JWTObject = reqHandler.getResponse().locals.jwtData;

            if(await this.validateRole(reqHandler,  jwtData.role, this.controllerObj.create, httpExec) !== true){ return; }

            // Validate the required fields of the entity
            if(!this.validateRequiredFields(reqHandler, validation)){ return; }

            // Validate the regex of the entity
            if(!this.validateRegex(reqHandler, validation)){ return; }

            // Set the user id of the entity
            let body = reqHandler.getAdapter().entityFromPostBody();
            body = this.setUserId(body, jwtData.id);

            try{
                // Insert the entity into the database
                const createdEntity = await this.getRepository().add(body);

                // Return the success response
                return httpExec.successAction(reqHandler.getAdapter().entityToResponse(createdEntity), ConstHTTPRequest.INSERT_SUCESS);

            }catch(error : any){
                // Return the database error response
                return await httpExec.databaseError(error, jwtData.id.toString(), 
                reqHandler.getMethod(), this.controllerObj.controller);
            }
        }catch(error : any){
            // Return the general error response
            return await httpExec.generalError(error, reqHandler.getMethod(), this.controllerObj.controller);
        }
     }
  

     /**
      * Update an entity in the database.
      *
      * @param reqHandler - The request handler.
      * @returns A promise that resolves to the updated entity.
      */
     async update(reqHandler: RequestHandler): Promise<any> {
        // Execute the returns structure
        const httpExec : HttpAction = reqHandler.getResponse().locals.httpExec;

        try {
            // Validate the role of the user
            const validation : Validations = reqHandler.getResponse().locals.validation;
            const jwtData : JWTObject = reqHandler.getResponse().locals.jwtData;

            // Validate the role of the user
            if (await this.validateRole(reqHandler, jwtData.role, this.controllerObj.update, httpExec) !== true) {
                return;
            }

            // Validate the regex of the entity
            if (!this.validateRegex(reqHandler, validation)) {
                return;
            }

            // Get the id from the URL params
            const validateId = this.getIdFromQuery(validation, httpExec);
            if(validateId === null){ return; }
            const id = validateId as number; 

            // If you need to validate if the user id of the table 
            // should be the user id of the user request (JWT)
            if(await this.validateUserIdEntityFindByCodeOrId(reqHandler, httpExec, jwtData, id) !== true){ return; }

            // Get data from the body
            const body = reqHandler.getAdapter().entityFromPutBody();

            try {
                // Execute the update action in the database
                const updateEntity = await this.getRepository().update(id, body,
                                                             reqHandler.getLogicalDelete());
                // Return the success response
                return httpExec.successAction(reqHandler.getAdapter().entityToResponse(updateEntity), ConstHTTPRequest.UPDATE_SUCCESS);

            } catch (error: any) {
                // Return the database error response
                return await httpExec.databaseError(error, jwtData.id.toString(), 
                reqHandler.getMethod(), this.controllerObj.controller);
            }

        } catch (error: any) {
            // Return the general error response
            return await httpExec.generalError(error, reqHandler.getMethod(), this.controllerObj.controller);
        }
     }

     /**
      * Delete an entity from the database.
      *
      * @param reqHandler - The request handler.
      * @returns A promise that resolves to the deleted entity.
      */
     async delete(reqHandler: RequestHandler): Promise<any> {
        // Get the HTTP action object from the response
        const httpExec : HttpAction = reqHandler.getResponse().locals.httpExec;

        try{
            // Get the validations object from the response
            const validation : Validations = reqHandler.getResponse().locals.validation;
            // Get the JWT object from the response
            const jwtData : JWTObject = reqHandler.getResponse().locals.jwtData;
            // Get the id from URL params
            const validateId = this.getIdFromQuery(validation, httpExec);
            if(validateId === null){ return; }
            const id = validateId as number; 

            // Validate the role of the user
            if(await this.validateRole(reqHandler, jwtData.role, this.controllerObj.delete, httpExec) !== true){ return; }
            // Validate the user id
            if(await this.validateUserIdEntityFindByCodeOrId(reqHandler, httpExec, jwtData, id) !== true){ return; }

            try{
                // Execute the delete action in the database
                if(reqHandler.getLogicalDelete()){
                    // Logically remove the entity from the database
                    const deletedEntity = await this.getRepository().logicalRemove(id);
                    return httpExec.successAction(reqHandler.getAdapter().entityToResponse(deletedEntity), ConstHTTPRequest.DELETE_SUCCESS);
                }else{
                    // Remove the entity from the database
                    const deletedEntity = await this.getRepository().remove(id);
                    return httpExec.successAction(reqHandler.getAdapter().entityToResponse(deletedEntity), ConstHTTPRequest.DELETE_SUCCESS);
                }
                
            }catch(error : any){
                // Return the database error response
                return await httpExec.databaseError(error, jwtData.id.toString(), 
                reqHandler.getMethod(), this.controllerObj.controller);
            }
        }catch(error : any){
            // Return the general error response
            return await httpExec.generalError(error, reqHandler.getMethod(), this.controllerObj.controller);
        }
     }

     /**
      * Get an entity by its ID from the database.
      *
      * @param reqHandler - The request handler.
      * @returns A promise that resolves to the entity.
      */
     async getById(reqHandler: RequestHandler): Promise<any> {
        // Get the HTTP action object from the response
        const httpExec : HttpAction = reqHandler.getResponse().locals.httpExec;

        try{
             // Get the validations object from the response
             const validation : Validations = reqHandler.getResponse().locals.validation;
             // Get the JWT object from the response
             const jwtData : JWTObject = reqHandler.getResponse().locals.jwtData;
             // Get the id from URL params
             const validateId = this.getIdFromQuery(validation, httpExec);
             if(validateId === null){ return; }
             const id = validateId as number; 

             // Validate the role of the user
             if(await this.validateRole(reqHandler, jwtData.role, this.controllerObj.getById, httpExec) !== true){ return; }
             // Validate the user id
             if(await this.validateUserIdEntityFindByCodeOrId(reqHandler, httpExec, jwtData, id) !== true){ return; }

            try{
                // Execute the get by id action in the database
                const entity = await this.getRepository().findById(id, reqHandler.getLogicalDelete());

                if(entity != null && entity != undefined){
                    // Return the success response
                    return httpExec.successAction(reqHandler.getAdapter().entityToResponse(entity), ConstHTTPRequest.GET_BY_ID_SUCCESS);
                }else{
                    return httpExec.dynamicError(ConstStatusJson.NOT_FOUND, ConstMessagesJson.DONT_EXISTS);
                }
                
            }catch(error : any){
                // Return the database error response
                return await httpExec.databaseError(error, jwtData.id.toString(), 
                reqHandler.getMethod(), this.controllerObj.controller);
            }
        }catch(error : any){
            // Return the general error response
            return await httpExec.generalError(error, reqHandler.getMethod(), this.controllerObj.controller);
        }
     }


     /**
      * Get an entity by its code from the database.
      *
      * @param reqHandler - The request handler.
      * @returns A promise that resolves to the entity.
      */
     async getByCode(reqHandler: RequestHandler): Promise<any> {
        // Get the HTTP action object from the response
        const httpExec : HttpAction = reqHandler.getResponse().locals.httpExec;

        try{
             // Get the validations object from the response
             const validation : Validations = reqHandler.getResponse().locals.validation;
             // Get the JWT object from the response
             const jwtData : JWTObject = reqHandler.getResponse().locals.jwtData;
             // Get the code from URL params
             const validateCode = this.getCodeFromQuery(validation, httpExec);
             if(validateCode === null){ return; }
             const code = validateCode as string; 

             // Validate the role of the user
             if(await this.validateRole(reqHandler, jwtData.role, this.controllerObj.getById, httpExec) !== true){ return; }
             // Validate the user id
             if(await this.validateUserIdEntityFindByCodeOrId(reqHandler, httpExec, jwtData, code) !== true){ return; }

            try{
                // Execute the get by code action in the database
                const entity = await this.getRepository().findByCode(code, reqHandler.getLogicalDelete());
                if(entity != null && entity != undefined){
                    // Return the success response
                    return httpExec.successAction(reqHandler.getAdapter().entityToResponse(entity), ConstHTTPRequest.GET_BY_ID_SUCCESS);
                }else{
                    return httpExec.dynamicError(ConstStatusJson.NOT_FOUND, ConstMessagesJson.DONT_EXISTS);
                }
                
            }catch(error : any){
                // Return the database error response
                return await httpExec.databaseError(error, jwtData.id.toString(), 
                reqHandler.getMethod(), this.controllerObj.controller);
            }
        }catch(error : any){
            // Return the general error response
            return await httpExec.generalError(error, reqHandler.getMethod(), this.controllerObj.controller);
        }
     }
   

    /**
     * Retrieves all entities from the database.
     *
     * @param reqHandler - The request handler.
     * @returns A promise that resolves to the entities.
     */
    async getAll(reqHandler: RequestHandler): Promise<any> {
        const config = ConfigManager.getInstance().getConfig();
        // Get the HTTP action object from the response
        const httpExec: HttpAction = reqHandler.getResponse().locals.httpExec;

        try {
            const jwtData: JWTObject = reqHandler.getResponse().locals.jwtData;

            // Validate the role of the user
            if (await this.validateRole(reqHandler, jwtData.role, this.controllerObj.getAll, httpExec) !== true) {
                return;
            }

            try {
                // Get the page and size from the URL query parameters
                const page: number = reqHandler.getRequest().query.page ?
                    parseInt(reqHandler.getRequest().query.page as string) :
                    config.HTTP_REQUEST.PAGE_OFFSET;

                const size: number = reqHandler.getRequest().query.size ?
                    parseInt(reqHandler.getRequest().query.size as string) :
                    config.HTTP_REQUEST.PAGE_SIZE;

                // Execute the get all action in the database
                const entities = await this.getRepository().findAll(reqHandler.getLogicalDelete(), page, size);
                if(entities != null && entities != undefined){
                    // Return the success response
                    return httpExec.successAction(reqHandler.getAdapter().entitiesToResponse(entities), ConstHTTPRequest.GET_ALL_SUCCESS);
                }else{
                    return httpExec.dynamicError(ConstStatusJson.NOT_FOUND, ConstMessagesJson.DONT_EXISTS);
                }

               
            } catch (error: any) {
                // Return the database error response
                return await httpExec.databaseError(error, jwtData.id.toString(),
                    reqHandler.getMethod(), this.controllerObj.controller);
            }
        } catch (error: any) {
            // Return the general error response
            return await httpExec.generalError(error, reqHandler.getMethod(), this.controllerObj.controller);
        }
    }
  

    /**
     * This function gets entities by applying filters specified in the request parameters.
     * 
     * @param {RequestHandler} reqHandler - The request handler object.
     * @returns {Promise<any>} A promise that resolves to the success response if the operation is successful.
     */
    async getByFilters(reqHandler: RequestHandler): Promise<any> {
        const config = ConfigManager.getInstance().getConfig();
        // Get the HTTP action object from the response
        const httpExec: HttpAction = reqHandler.getResponse().locals.httpExec;

        try {
            // Get the JWT data from the response
            const jwtData: JWTObject = reqHandler.getResponse().locals.jwtData;

            // Validate the role of the user
            await this.validateRole(reqHandler, jwtData.role, this.controllerObj.getById, httpExec);

            // Check if filters are provided in the request parameters
            if (reqHandler.getFilters() == null) {
                return httpExec.paramsError(); // Return error response if filters are not provided
            }

            try {
                // Get the page and size from the URL query parameters
                const page: number = reqHandler.getRequest().query.page ?
                    parseInt(reqHandler.getRequest().query.page as string) :
                    config.HTTP_REQUEST.PAGE_OFFSET;

                const size: number = reqHandler.getRequest().query.size ?
                    parseInt(reqHandler.getRequest().query.size as string) :
                    config.HTTP_REQUEST.PAGE_SIZE;

                // Execute the find by filters action in the database
                const entities = await this.getRepository().findByFilters(reqHandler.getFilters()!,
                    reqHandler.getLogicalDelete(), page, size);

                if(entities != null && entities != undefined){
                    // Return the success response
                    return httpExec.successAction(reqHandler.getAdapter().entitiesToResponse(entities), ConstHTTPRequest.GET_ALL_SUCCESS);
                }else{
                    return httpExec.dynamicError(ConstStatusJson.NOT_FOUND, ConstMessagesJson.DONT_EXISTS);
                }

            } catch (error: any) {
                // Return the database error response
                return await httpExec.databaseError(error, jwtData.id.toString(),
                    reqHandler.getMethod(), this.controllerObj.controller);
            }
        } catch (error: any) {
            // Return the general error response
            return await httpExec.generalError(error, reqHandler.getMethod(), this.controllerObj.controller);
        }
    }
}